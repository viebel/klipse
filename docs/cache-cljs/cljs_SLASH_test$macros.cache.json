["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$cljs.test$macros","~:imports",null,"~:requires",["^ ","~$env","~$cljs.env","^<","^<","~$ana","~$cljs.analyzer","^>","^>","~$ana-api","~$cljs.analyzer.api","^@","^@"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$are",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$cljs.test","~:end-column",14,"~:top-fn",["^ ","~:variadic",true,"~:max-fixed-arity",4,"~:method-params",[["~#list",["~$&form","~$&env","~$argv","~$expr","~$args"]]],"~:arglists",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"~:arglists-meta",["^N",[null]]],"~:column",11,"~:line",172,"~:macro",true,"~:end-line",172,"^T",["^N",["~$quote",["^N",[["^Q","^R","~$&","^S"]]]]],"~:doc","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers."],"^7","~$cljs.test$macros/are","^K",true,"^G","cljs/test.cljc","^I",14,"^J",["^ ","^K",true,"^L",4,"^M",[["^N",["^O","^P","^Q","^R","^S"]]],"^T",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^Q","^R","^S"]]],"~:protocol-impl",null,"^U",["^N",[null]],"^V",1,"^W",172,"^X",true,"^Y",172,"^L",4,"~:fn-var",false,"^T",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"^[","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers."],"~$ns?",["^ ","^E",null,"^F",["^ ","^G","^H","^W",250,"^V",7,"^Y",250,"^I",10,"^T",["^N",["^Z",["^N",[["~$x"]]]]]],"^7","~$cljs.test$macros/ns?","^K",false,"^G","cljs/test.cljc","^I",10,"^M",["^N",[["~$x"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",250,"^Y",250,"^L",1,"^12",true,"^T",["^N",["^Z",["^N",[["~$x"]]]]]],"~$test-all-vars",["^ ","^E",null,"^F",["^ ","^G","^H","^W",339,"^V",11,"^Y",339,"^I",24,"^X",true,"^T",["^N",["^Z",["^N",[[["^Z","~$ns","~:as","~$form"]]]]]],"^[","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures."],"^7","~$cljs.test$macros/test-all-vars","^K",false,"^G","cljs/test.cljc","^I",24,"^M",["^N",[["^O","^P","~$p__2839"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",339,"^X",true,"^Y",339,"^L",3,"^12",false,"^T",["^N",["^Z",["^N",[[["^Z","^16","^17","^18"]]]]]],"^[","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures."],"~$run-all-tests",["^ ","^E",null,"^F",["^ ","^G","^H","^I",24,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P"],["^O","^P","~$re"],["^O","^P","^1<","^;"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^U",["^N",[null,null,null]]],"^V",11,"^W",302,"^X",true,"^Y",302,"^T",["^N",["^Z",["^N",[[],["^1<"],["^1<","^;"]]]]],"^[","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested."],"^7","~$cljs.test$macros/run-all-tests","^K",false,"^G","cljs/test.cljc","^I",24,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^U",["^N",[null,null,null]]],"^M",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^11",null,"^U",["^N",[null,null,null]],"^V",1,"^W",302,"^X",true,"^Y",302,"^L",4,"^12",false,"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^[","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested."],"~$assert-any",["^ ","^E",null,"^F",["^ ","^G","^H","^W",45,"^V",7,"^Y",45,"^I",17,"^T",["^N",["^Z",["^N",[["~$msg","^18"]]]]],"^[","Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols."],"^7","~$cljs.test$macros/assert-any","^K",false,"^G","cljs/test.cljc","^I",17,"^M",["^N",[["^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",45,"^Y",45,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols."],"~$testing",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$string","~$body"]]],"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",196,"^X",true,"^Y",196,"^T",["^N",["^Z",["^N",[["^1B","~$&","^1C"]]]]],"^[","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest)."],"^7","~$cljs.test$macros/testing","^K",true,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1B","^1C"]]],"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1B","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",196,"^X",true,"^Y",196,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^[","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest)."],"~$assert-expr",["^ ","^7","~$cljs.test$macros/assert-expr","^G","cljs/test.cljc","^W",70,"^V",1,"^Y",70,"^I",22,"^F",["^ ","^G","^H","^W",70,"^V",11,"^Y",70,"^I",22],"~:tag","~$cljs.core/MultiFn"],"~$async",["^ ","^E",null,"^F",["^ ","^G","^H","^I",16,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$done","^1C"]]],"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",228,"^X",true,"^Y",228,"^T",["^N",["^Z",["^N",[["^1J","~$&","^1C"]]]]],"^[","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))"],"^7","~$cljs.test$macros/async","^K",true,"^G","cljs/test.cljc","^I",16,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1J","^1C"]]],"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1J","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",228,"^X",true,"^Y",228,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^[","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))"],"~$is",["^ ","^E",null,"^F",["^ ","^G","^H","^I",13,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^U",["^N",[null,null]]],"^V",11,"^W",154,"^X",true,"^Y",154,"^T",["^N",["^Z",["^N",[["^18"],["^18","^1?"]]]]],"^[","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re."],"^7","~$cljs.test$macros/is","^K",false,"^G","cljs/test.cljc","^I",13,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^U",["^N",[null,null]]],"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",154,"^X",true,"^Y",154,"^L",4,"^12",false,"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^[","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re."],"~$deftest",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$name","^1C"]]],"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",210,"^X",true,"^Y",210,"^T",["^N",["^Z",["^N",[["^1O","~$&","^1C"]]]]],"^[","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored."],"^7","~$cljs.test$macros/deftest","^K",true,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1O","^1C"]]],"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1O","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",210,"^X",true,"^Y",210,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^[","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored."],"~$assert-predicate",["^ ","^E",null,"^F",["^ ","^G","^H","^W",25,"^V",7,"^Y",25,"^I",23,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...)."],"^7","~$cljs.test$macros/assert-predicate","^K",false,"^G","cljs/test.cljc","^I",23,"^M",["^N",[["^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",25,"^Y",25,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...)."],"~$cljs-output-dir",["^ ","^E",null,"^F",["^ ","^G","^H","^W",59,"^V",21,"^Y",59,"^I",36,"~:private",true,"^X",true,"^T",["^N",["^Z",["^N",[[]]]]]],"^1T",true,"^7","~$cljs.test$macros/cljs-output-dir","^K",false,"^G","cljs/test.cljc","^I",36,"^M",["^N",[["^O","^P"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",59,"^X",true,"^Y",59,"^L",2,"^12",false,"^T",["^N",["^Z",["^N",[[]]]]]],"~$function?",["^ ","^E",null,"^F",["^ ","^G","^H","^W",19,"^V",7,"^Y",19,"^I",16,"^T",["^N",["^Z",["^N",[["~$menv","~$x"]]]]],"^[","Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro)."],"^7","~$cljs.test$macros/function?","^K",false,"^G","cljs/test.cljc","^I",16,"^M",["^N",[["^1W","~$x"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",19,"^Y",19,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1W","~$x"]]]]],"^[","Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro)."],"~$run-tests-block",["^ ","^E",null,"^F",["^ ","^G","^H","^I",26,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$env-or-ns","~$namespaces"]]],"^T",["^N",[["^O","^P","^1Z","~$&","^1["]]],"^U",["^N",[null]]],"^V",11,"^W",253,"^X",true,"^Y",253,"^T",["^N",["^Z",["^N",[["^1Z","~$&","^1["]]]]],"^[","Like test-vars, but returns a block for further composition and\n  later execution."],"^7","~$cljs.test$macros/run-tests-block","^K",true,"^G","cljs/test.cljc","^I",26,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1Z","^1["]]],"^T",["^N",[["^O","^P","^1Z","~$&","^1["]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1Z","^1["]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",253,"^X",true,"^Y",253,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1Z","~$&","^1["]]],"^[","Like test-vars, but returns a block for further composition and\n  later execution."],"~$test-ns-block",["^ ","^E",null,"^F",["^ ","^G","^H","^W",348,"^V",11,"^Y",348,"^I",24,"^X",true,"^T",["^N",["^Z",["^N",[["^;",["^Z","^16","^17","^18"]]]]]],"^[","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env."],"^7","~$cljs.test$macros/test-ns-block","^K",false,"^G","cljs/test.cljc","^I",24,"^M",["^N",[["^O","^P","^;","~$p__2844"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",348,"^X",true,"^Y",348,"^L",4,"^12",false,"^T",["^N",["^Z",["^N",[["^;",["^Z","^16","^17","^18"]]]]]],"^[","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env."],"~$try-expr",["^ ","^E",null,"^F",["^ ","^G","^H","^W",140,"^V",11,"^Y",140,"^I",19,"^X",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this."],"^7","~$cljs.test$macros/try-expr","^K",false,"^G","cljs/test.cljc","^I",19,"^M",["^N",[["^O","^P","^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",140,"^X",true,"^Y",140,"^L",4,"^12",false,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this."],"~$use-fixtures",["^ ","^E",null,"^F",["^ ","^G","^H","^W",382,"^V",11,"^Y",382,"^I",23,"^X",true,"^T",["^N",["^Z",["^N",[["~$type","~$&","~$fns"]]]]],"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^27","^28"]]],"^T",["^N",[["^O","^P","^27","~$&","^28"]]],"^U",["^N",[null]]]],"^7","~$cljs.test$macros/use-fixtures","^K",true,"^G","cljs/test.cljc","^I",23,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^27","^28"]]],"^T",["^N",[["^O","^P","^27","~$&","^28"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^27","^28"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",382,"^X",true,"^Y",382,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^27","~$&","^28"]]]],"~$test-ns",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^U",["^N",[null,null]]],"^V",11,"^W",365,"^X",true,"^Y",365,"^T",["^N",["^Z",["^N",[["^16"],["^;",["^Z","^16","^17","^18"]]]]]],"^[","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  "],"^7","~$cljs.test$macros/test-ns","^K",false,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^U",["^N",[null,null]]],"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",365,"^X",true,"^Y",365,"^L",4,"^12",false,"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^[","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  "],"~$test-all-vars-block",["^ ","^E",null,"^F",["^ ","^G","^H","^W",316,"^V",11,"^Y",316,"^I",30,"^X",true,"^T",["^N",["^Z",["^N",[[["^Z","^16"]]]]]]],"^7","~$cljs.test$macros/test-all-vars-block","^K",false,"^G","cljs/test.cljc","^I",30,"^M",["^N",[["^O","^P","~$p__2738"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",316,"^X",true,"^Y",316,"^L",3,"^12",false,"^T",["^N",["^Z",["^N",[[["^Z","^16"]]]]]]],"~$run-tests",["^ ","^E",null,"^F",["^ ","^G","^H","^I",20,"^J",["^ ","^K",true,"^L",3,"^M",["^N",[["^O","^P"],["^O","^P","^1Z"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1Z"],["^O","^P","^1Z","~$&","^1["]]],"^U",["^N",[null,null,null]]],"^V",11,"^W",288,"^X",true,"^Y",288,"^T",["^N",["^Z",["^N",[[],["^1Z"],["^1Z","~$&","^1["]]]]],"^[","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod."],"^7","~$cljs.test$macros/run-tests","^K",true,"^G","cljs/test.cljc","^I",20,"^J",["^ ","^K",true,"^L",3,"^M",["^N",[["^O","^P"],["^O","^P","^1Z"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1Z"],["^O","^P","^1Z","~$&","^1["]]],"^U",["^N",[null,null,null]]],"^M",["^N",[["^O","^P"],["^O","^P","^1Z"]]],"^11",null,"^U",["^N",[null,null,null]],"^V",1,"^W",288,"^X",true,"^Y",288,"^L",3,"^12",false,"^T",["^N",[["^O","^P"],["^O","^P","^1Z"],["^O","^P","^1Z","~$&","^1["]]],"^[","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$temp","~$clojure.template","^2D","^2D"],"^[",null]