["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.template$macros","~:imports",null,"~:requires",["^ ","~$walk","~$clojure.walk","^<","^<"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$apply-template",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$clojure.template","~:line",30,"~:column",7,"~:end-line",30,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^J",[["~$argv","~$expr","~$values"]]]]],"~:doc","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"^7","~$clojure.template$macros/apply-template","~:variadic",false,"^C","clojure/template.clj","^H",21,"~:method-params",["^J",[["^L","^M","^N"]]],"~:protocol-impl",null,"~:arglists-meta",["^J",[null,null]],"^F",1,"^E",30,"^G",30,"~:max-fixed-arity",3,"~:fn-var",true,"^I",["^J",["^K",["^J",[["^L","^M","^N"]]]]],"^O","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"~$do-template",["^ ","^A",null,"^B",["^ ","^C","^D","^H",22,"~:top-fn",["^ ","^Q",true,"^U",4,"^R",[["^J",["~$&form","~$&env","^L","^M","^N"]]],"^I",["^J",[["^Y","^Z","^L","^M","~$&","^N"]]],"^T",["^J",[null]]],"^F",11,"^E",45,"~:macro",true,"^G",45,"^I",["^J",["^K",["^J",[["^L","^M","~$&","^N"]]]]],"^O","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"],"^7","~$clojure.template$macros/do-template","^Q",true,"^C","clojure/template.clj","^H",22,"^X",["^ ","^Q",true,"^U",4,"^R",[["^J",["^Y","^Z","^L","^M","^N"]]],"^I",["^J",[["^Y","^Z","^L","^M","~$&","^N"]]],"^T",["^J",[null]]],"^R",[["^J",["^Y","^Z","^L","^M","^N"]]],"^S",null,"^T",["^J",[null]],"^F",1,"^E",45,"^[",true,"^G",45,"^U",4,"^V",false,"^I",["^J",[["^Y","^Z","^L","^M","~$&","^N"]]],"^O","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~$do"]],"~:order",["^15"]],"^O",null]