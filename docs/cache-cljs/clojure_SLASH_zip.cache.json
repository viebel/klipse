["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",["~$replace","~$remove","~$next"]],"~:name","~$clojure.zip","~:imports",null,"~:requires",null,"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$rightmost",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^9","~:line",142,"~:column",7,"~:end-line",142,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^H",[["~$loc"]]]]],"~:doc","Returns the loc of the rightmost sibling of the node at this loc, or self"],"^8","~$clojure.zip/rightmost","~:variadic",false,"^B","clojure/zip.cljs","^F",16,"~:method-params",["^H",[["^J"]]],"~:protocol-impl",null,"~:arglists-meta",["^H",[null,null]],"^D",1,"^C",142,"^E",142,"~:max-fixed-arity",1,"~:fn-var",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the rightmost sibling of the node at this loc, or self"],"~$insert-child",["^ ","^@",null,"^A",["^ ","^B","^9","^C",194,"^D",7,"^E",194,"^F",19,"^G",["^H",["^I",["^H",[["^J","~$item"]]]]],"^K","Inserts the item as the leftmost child of the node at this loc,\n  without moving"],"^8","~$clojure.zip/insert-child","^M",false,"^B","clojure/zip.cljs","^F",19,"^N",["^H",[["^J","^T"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",194,"^E",194,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the leftmost child of the node at this loc,\n  without moving"],"~$left",["^ ","^@",null,"^A",["^ ","^B","^9","^C",150,"^D",7,"^E",150,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the left sibling of the node at this loc, or nil"],"^8","~$clojure.zip/left","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",150,"^E",150,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the left sibling of the node at this loc, or nil"],"~$path",["^ ","^@",null,"^A",["^ ","^B","^9","^C",82,"^D",7,"^E",82,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of nodes leading to this loc"],"^8","~$clojure.zip/path","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",82,"^E",82,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of nodes leading to this loc"],"~$leftmost",["^ ","^@",null,"^A",["^ ","^B","^9","^C",157,"^D",7,"^E",157,"^F",15,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the leftmost sibling of the node at this loc, or self"],"^8","~$clojure.zip/leftmost","^M",false,"^B","clojure/zip.cljs","^F",15,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",157,"^E",157,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the leftmost sibling of the node at this loc, or self"],"~$append-child",["^ ","^@",null,"^A",["^ ","^B","^9","^C",200,"^D",7,"^E",200,"^F",19,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the rightmost child of the node at this loc,\n  without moving"],"^8","~$clojure.zip/append-child","^M",false,"^B","clojure/zip.cljs","^F",19,"^N",["^H",[["^J","^T"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",200,"^E",200,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the rightmost child of the node at this loc,\n  without moving"],"~$branch?",["^ ","^@",null,"^A",["^ ","^B","^9","^C",64,"^D",7,"^E",64,"^F",14,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns true if the node at loc is a branch"],"^8","~$clojure.zip/branch?","^M",false,"^B","clojure/zip.cljs","^F",14,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",64,"^E",64,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns true if the node at loc is a branch"],"~$children",["^ ","^@",null,"^A",["^ ","^B","^9","^C",69,"^D",7,"^E",69,"^F",15,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the children of node at loc, which must be a branch"],"^8","~$clojure.zip/children","^M",false,"^B","clojure/zip.cljs","^F",15,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",69,"^E",69,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the children of node at loc, which must be a branch"],"^6",["^ ","^@",null,"^A",["^ ","^B","^9","^C",237,"^D",7,"^E",237,"^F",13,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],"^8","~$clojure.zip/remove","^M",false,"^B","clojure/zip.cljs","^F",13,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",237,"^E",237,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."],"~$down",["^ ","^@",null,"^A",["^ ","^B","^9","^C",98,"^D",7,"^E",98,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],"^8","~$clojure.zip/down","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",98,"^E",98,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"],"^5",["^ ","^@",null,"^A",["^ ","^B","^9","^C",183,"^D",7,"^E",183,"^F",14,"^G",["^H",["^I",["^H",[["^J","~$node"]]]]],"^K","Replaces the node at this loc, without moving"],"^8","~$clojure.zip/replace","^M",false,"^B","clojure/zip.cljs","^F",14,"^N",["^H",[["^J","^19"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",183,"^E",183,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^J","^19"]]]]],"^K","Replaces the node at this loc, without moving"],"~$zipper",["^ ","^@",null,"^A",["^ ","^B","^9","^C",18,"^D",7,"^E",18,"^F",13,"^G",["^H",["^I",["^H",[["^12","^14","~$make-node","~$root"]]]]],"^K","Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],"^8","~$clojure.zip/zipper","^M",false,"^B","clojure/zip.cljs","^F",13,"^N",["^H",[["^12","^14","^1<","^1="]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",18,"^E",18,"^Q",4,"^R",true,"^G",["^H",["^I",["^H",[["^12","^14","^1<","^1="]]]]],"^K","Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."],"~$end?",["^ ","^@",null,"^A",["^ ","^B","^9","^C",232,"^D",7,"^E",232,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns true if loc represents the end of a depth-first walk"],"^8","~$clojure.zip/end?","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",232,"^E",232,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns true if loc represents the end of a depth-first walk"],"~$edit",["^ ","^@",null,"^A",["^ ","^B","^9","^C",189,"^D",7,"^E",189,"^F",11,"^G",["^H",["^I",["^H",[["^J","~$f","~$&","~$args"]]]]],"^K","Replaces the node at this loc with the value of (f node args)","~:top-fn",["^ ","^M",true,"^Q",2,"^N",[["^H",["^J","~$f","^1B"]]],"^G",["^H",[["^J","~$f","~$&","^1B"]]],"^P",["^H",[null]]]],"^8","~$clojure.zip/edit","^M",true,"^B","clojure/zip.cljs","^F",11,"^1C",["^ ","^M",true,"^Q",2,"^N",[["^H",["^J","~$f","^1B"]]],"^G",["^H",[["^J","~$f","~$&","^1B"]]],"^P",["^H",[null]]],"^N",[["^H",["^J","~$f","^1B"]]],"^O",null,"^P",["^H",[null]],"^D",1,"^C",189,"^E",189,"^Q",2,"^R",true,"^G",["^H",[["^J","~$f","~$&","^1B"]]],"^K","Replaces the node at this loc with the value of (f node args)"],"^1<",["^ ","^@",null,"^A",["^ ","^B","^9","^C",76,"^D",7,"^E",76,"^F",16,"^G",["^H",["^I",["^H",[["^J","^19","^14"]]]]],"^K","Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],"^8","~$clojure.zip/make-node","^M",false,"^B","clojure/zip.cljs","^F",16,"^N",["^H",[["^J","^19","^14"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",76,"^E",76,"^Q",3,"^R",true,"^G",["^H",["^I",["^H",[["^J","^19","^14"]]]]],"^K","Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."],"~$vector-zip",["^ ","^@",null,"^A",["^ ","^B","^9","^C",42,"^D",7,"^E",42,"^F",17,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for nested vectors, given a root vector"],"^8","~$clojure.zip/vector-zip","^M",false,"^B","clojure/zip.cljs","^F",17,"^N",["^H",[["^1="]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",42,"^E",42,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for nested vectors, given a root vector"],"^19",["^ ","^@",null,"^A",["^ ","^B","^9","^C",60,"^D",7,"^E",60,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the node at loc"],"^8","~$clojure.zip/node","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",60,"^E",60,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the node at loc"],"~$up",["^ ","^@",null,"^A",["^ ","^B","^9","^C",111,"^D",7,"^E",111,"^F",9,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],"^8","~$clojure.zip/up","^M",false,"^B","clojure/zip.cljs","^F",9,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",111,"^E",111,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the parent of the node at this loc, or nil if at\n  the top"],"~$insert-right",["^ ","^@",null,"^A",["^ ","^B","^9","^C",174,"^D",7,"^E",174,"^F",19,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the right sibling of the node at this loc,\n  without moving"],"^8","~$clojure.zip/insert-right","^M",false,"^B","clojure/zip.cljs","^F",19,"^N",["^H",[["^J","^T"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",174,"^E",174,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the right sibling of the node at this loc,\n  without moving"],"~$rights",["^ ","^@",null,"^A",["^ ","^B","^9","^C",92,"^D",7,"^E",92,"^F",13,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the right siblings of this loc"],"^8","~$clojure.zip/rights","^M",false,"^B","clojure/zip.cljs","^F",13,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",92,"^E",92,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the right siblings of this loc"],"^1=",["^ ","^@",null,"^A",["^ ","^B","^9","^C",124,"^D",7,"^E",124,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","zips all the way up and returns the root node, reflecting any\n changes."],"^8","~$clojure.zip/root","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",124,"^E",124,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","zips all the way up and returns the root node, reflecting any\n changes."],"^7",["^ ","^@",null,"^A",["^ ","^B","^9","^C",206,"^D",7,"^E",206,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],"^8","~$clojure.zip/next","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",206,"^E",206,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."],"~$seq-zip",["^ ","^@",null,"^A",["^ ","^B","^9","^C",34,"^D",7,"^E",34,"^F",14,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for nested sequences, given a root sequence"],"^8","~$clojure.zip/seq-zip","^M",false,"^B","clojure/zip.cljs","^F",14,"^N",["^H",[["^1="]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",34,"^E",34,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for nested sequences, given a root sequence"],"~$insert-left",["^ ","^@",null,"^A",["^ ","^B","^9","^C",165,"^D",7,"^E",165,"^F",18,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the left sibling of the node at this loc,\n without moving"],"^8","~$clojure.zip/insert-left","^M",false,"^B","clojure/zip.cljs","^F",18,"^N",["^H",[["^J","^T"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",165,"^E",165,"^Q",2,"^R",true,"^G",["^H",["^I",["^H",[["^J","^T"]]]]],"^K","Inserts the item as the left sibling of the node at this loc,\n without moving"],"~$prev",["^ ","^@",null,"^A",["^ ","^B","^9","^C",221,"^D",7,"^E",221,"^F",11,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],"^8","~$clojure.zip/prev","^M",false,"^B","clojure/zip.cljs","^F",11,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",221,"^E",221,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."],"~$right",["^ ","^@",null,"^A",["^ ","^B","^9","^C",135,"^D",7,"^E",135,"^F",12,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the right sibling of the node at this loc, or nil"],"^8","~$clojure.zip/right","^M",false,"^B","clojure/zip.cljs","^F",12,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",135,"^E",135,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns the loc of the right sibling of the node at this loc, or nil"],"~$lefts",["^ ","^@",null,"^A",["^ ","^B","^9","^C",87,"^D",7,"^E",87,"^F",12,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the left siblings of this loc"],"^8","~$clojure.zip/lefts","^M",false,"^B","clojure/zip.cljs","^F",12,"^N",["^H",[["^J"]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",87,"^E",87,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^J"]]]]],"^K","Returns a seq of the left siblings of this loc"],"~$xml-zip",["^ ","^@",null,"^A",["^ ","^B","^9","^C",50,"^D",7,"^E",50,"^F",14,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for xml elements (as from xml/parse),\n  given a root element"],"^8","~$clojure.zip/xml-zip","^M",false,"^B","clojure/zip.cljs","^F",14,"^N",["^H",[["^1="]]],"^O",null,"^P",["^H",[null,null]],"^D",1,"^C",50,"^E",50,"^Q",1,"^R",true,"^G",["^H",["^I",["^H",[["^1="]]]]],"^K","Returns a zipper for xml elements (as from xml/parse),\n  given a root element"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:ppath","~:zip/branch?","~:r","~:zip/children","~:content","~:l","~:zip/make-node","~:pnodes","~:changed?","~:end"]],"~:order",["^26","^27","^29","^28","^2:","~:l","~:r","^25","^2;","^2<"]],"^K","Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"]