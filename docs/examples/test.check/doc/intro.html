<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Introduction to test.check</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" /><div style="visibility: hidden;"><div class="klipse" data-external-libs="https://raw.githubusercontent.com/clojure/test.check/master/src/main/clojure">(ns my.test
                                                                  (:require [clojure.test.check :as tc :refer [quick-check]]
                                                                            [clojure.test.check.generators :as gen]
                                                                            [clojure.test.check.properties :as prop :include-macros true :refer [for-all]]))</div></div><div id="header"><h2><button id="klipse-button">InteractiveDoc</button></h2><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Test.check</span> <span class="project-version">0.9.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="cheatsheet.html"><div class="inner"><span>test.check cheatsheet</span></div></a></li><li class="depth-1 "><a href="generator-examples.html"><div class="inner"><span>Generator Examples</span></div></a></li><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Introduction to test.check</span></div></a></li><li class="depth-1 "><a href="migrating-from-simple-check.html"><div class="inner"><span>Migrating from simple-check</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></div></li><li class="depth-3"><a href="clojure.test.check.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>check</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.clojure-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure-test</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.generators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generators</span></div></a></li><li class="depth-4"><a href="clojure.test.check.properties.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>properties</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#introduction-to-test-check" name="introduction-to-test-check"></a>Introduction to test.check</h1>
<p>test.check is a tool for writing property-based tests. This differs from traditional unit-testing, where you write individual test-cases. With test.check you write universal quantifications, properties that should hold true for all input. For example, for all vectors, reversing the vector should preserve the count. Reversing it twice should equal the input. In this guide, we’ll cover the thought process for coming up with properties, as well as the practice of writing the tests themselves.</p>
<h2><a href="#a-simple-example" name="a-simple-example"></a>A simple example</h2>
<p>First, let’s start with an example, suppose we want to test a sort function. It’s easy to come up with some trivial properties for our function, namely that the output should be in ascending order. We also might want to make sure that the count of the input is preserved. Our test might look like:</p>
<pre><code class="clojure">(require '[clojure.test.check :as tc])
(require '[clojure.test.check.generators :as gen])
(require '[clojure.test.check.properties :as prop])
</code></pre>
<pre><code class="clojure">(defn ascending?
  "clojure.core/sorted? doesn't do what we might expect, so we write our
  own function"
  [coll]
  (every? (fn [[a b]] (&lt;= a b))
          (partition 2 1 coll)))

(def property
  (prop/for-all [v (gen/vector gen/int)]
    (let [s (sort v)]
      (and (= (count v) (count s))
           (ascending? s)))))
</code></pre>
<p>Let’s test our property</p>
<pre><code class="clojure">(tc/quick-check 100 property)
</code></pre>
<p>What if we were to forget to actually sort our vector? The test will fail, and then test.check will try and find ‘smaller’ inputs that still cause the test to fail. For example, the function might originally fail with input: <code>[5 4 2 2 2]</code>, but test.check will shrink this down to <code>[0 -1]</code> (or <code>[1 0]</code>).</p>
<pre><code class="clojure">(def bad-property
  (prop/for-all [v (gen/vector gen/int)]
    (ascending? v)))

(tc/quick-check 100 bad-property)
</code></pre>
<p>This process of shrinking is done automatically, even for our more complex generators that we write ourselves.</p>
<h2><a href="#generators" name="generators"></a>Generators</h2>
<p>In order to write our property, we’ll use generators. A generator knows how to generate random values for a specific type. The <code>test.check.generators</code> namespace has many built-in generators, as well as combinators for creating your own new generators. You can write sophisticated generators just by combining the existing generators with the given combinators. As we write generators, we can see them in practice with the <code>sample</code> function:</p>
<pre><code class="clojure">(require '[clojure.test.check.generators :as gen])
</code></pre>
<pre><code class="clojure">(gen/sample gen/int)
</code></pre>
<p>we can ask for more samples:</p>
<pre><code class="clojure">(gen/sample gen/int 20)
</code></pre>
<p>or get a lazy-seq of values:</p>
<pre><code class="clojure">(take 1 (gen/sample-seq gen/int))
</code></pre>
<p>You may notice that as you ask for more values, the ‘size’ of the generated values increases. As test.check generates more values, it increases the ‘size’ of the generated values. This allows tests to fail early, for simple values, and only increase the size as the test continues to pass.</p>
<h3><a href="#compound-generators" name="compound-generators"></a>Compound generators</h3>
<p>Some generators take other generators as arguments. For example the <code>vector</code> and <code>list</code> generator:</p>
<pre><code class="clojure">(gen/sample (gen/vector gen/nat))
</code></pre>
<pre><code class="clojure">(gen/sample (gen/list gen/boolean))
</code></pre>
<pre><code class="clojure">(gen/sample (gen/map gen/keyword gen/boolean) 5)
</code></pre>
<p>Sometimes we’ll want to create heterogeneous collections. The <code>tuple</code> generator allows us to to do this:</p>
<pre><code class="clojure">(gen/sample (gen/tuple gen/nat gen/boolean gen/ratio))
</code></pre>
<h3><a href="#generator-combinators" name="generator-combinators"></a>Generator combinators</h3>
<p>There are several generator combinators, we’ll take a look at <code>fmap</code>, <code>such-that</code> and <code>bind</code>.</p>
<h4><a href="#fmap" name="fmap"></a>fmap</h4>
<p><code>fmap</code> allows us to create a new generator by applying a function to the values generated by another generator. Let’s say we want to to create a set of natural numbers. We can create a set by calling <code>set</code> on a vector. So let’s create a vector of natural numbers (using the <code>nat</code> generator), and then use <code>fmap</code> to call <code>set</code> on the values:</p>
<pre><code class="clojure">(gen/sample (gen/fmap set (gen/vector gen/nat)))
</code></pre>
<p>Imagine you have a record, that has a convenience creation function, <code>foo</code>. You can create random <code>foo</code>s by generating the types of the arguments to <code>foo</code> with <code>tuple</code>, and then using <code>(fmap foo (tuple ...))</code>.</p>
<h4><a href="#such-that" name="such-that"></a>such-that</h4>
<p><code>such-that</code> allows us to create a generator that passes a predicate. Imagine we wanted to generate non-empty lists, we can use <code>such-that</code> to filter out empty lists:</p>
<pre><code class="clojure">(gen/sample (gen/such-that not-empty (gen/list gen/boolean)))
</code></pre>
<h4><a href="#bind" name="bind"></a>bind</h4>
<p><code>bind</code> allows us to create a new generator based on the <em>value</em> of a previously created generator. For example, say we wanted to generate a vector of keywords, and then choose a random element from it, and return both the vector and the random element. <code>bind</code> takes a generator, and a function that takes a value from that generator, and creates a new generator.</p>
<pre><code class="clojure">(def keyword-vector (gen/such-that not-empty (gen/vector gen/keyword)))
(def vec-and-elem
  (gen/bind keyword-vector
            (fn [v] (gen/tuple (gen/elements v) (gen/return v)))))

(gen/sample vec-and-elem 4)
</code></pre>
<p>This allows us to build quite sophisticated generators.</p>
<h3><a href="#record-generators" name="record-generators"></a>Record generators</h3>
<p>Let’s go through an example of generating random values of our own <code>defrecord</code>s. Let’s create a simple user record:</p>
<pre><code class="clojure">(defrecord User [user-name user-id email active?])
</code></pre>
<p>Recall that a helper function is automatically generated for us</p>
<pre><code class="clojure">(-&gt;User "reiddraper" 15 "reid@example.com" true)
</code></pre>
<p>We can use the <code>-&gt;User</code> helper function to construct our user. First, let’s look at the generators we’ll use for the arguments. For the user-name, we can just use an alphanumeric string, user IDs will be natural numbers, we’ll construct our own simple email generator, and we’ll use booleans to denote whether the user account is active. Let’s write a simple email address generator:</p>
<pre><code class="clojure">(def domain (gen/elements ["gmail.com" "hotmail.com" "computer.org"]))
(def email-gen
  (gen/fmap (fn [[name domain-name]]
              (str name "@" domain-name))
            (gen/tuple (gen/not-empty gen/string-alphanumeric) domain)))

(last (gen/sample email-gen))
</code></pre>
<p>To put it all together, we’ll use <code>fmap</code> to call our record constructor, and <code>tuple</code> to create a vector of the arguments:</p>
<pre><code class="clojure">(def user-gen
  (gen/fmap (partial apply -&gt;User)
            (gen/tuple (gen/not-empty gen/string-alphanumeric)
                       gen/nat
                       email-gen
                       gen/boolean)))

(last (gen/sample user-gen))
</code></pre>
<h3><a href="#recursive-generators" name="recursive-generators"></a>Recursive generators</h3>
<hr />
<p>NOTE: Writing recursive generators was significantly simplified in version 0.5.9. For the old way, see the <a href="https://github.com/clojure/test.check/blob/v0.5.8/doc/intro.md#recursive-generators">0.5.8 documentation</a>.</p>
<hr />
<p>Writing recursive, or tree-shaped generators is easy using <code>gen/recursive-gen</code>. <code>recursive-gen</code> takes two arguments, a compound generator, and a scalar generator. We’ll start with a simple example, and then move into something more complex. First, let’s generate a nested vector of booleans. So our compound generator will be <code>gen/vector</code> and our scalar will be <code>gen/boolean</code>:</p>
<pre><code class="clojure">(def nested-vector-of-boolean (gen/recursive-gen gen/vector gen/boolean))
(last (gen/sample nested-vector-of-boolean 20))
</code></pre>
<p>Now, let’s make our own, JSON-like generator. We’ll allow <code>gen/list</code> and <code>gen/map</code> as our compound types and <code>gen/int</code> and <code>gen/boolean</code> as our scalar types. Since <code>recursive-gen</code> only accepts one of each type of generator, we’ll combine our compound types with a simple function, and the two scalars with <code>gen/one-of</code>.</p>
<pre><code class="clojure">(def compound (fn [inner-gen]
                  (gen/one-of [(gen/list inner-gen)
                               (gen/map inner-gen inner-gen)])))
(def scalars (gen/one-of [gen/int gen/boolean]))
(def my-json-like-thing (gen/recursive-gen compound scalars))
(last (gen/sample my-json-like-thing 20))
</code></pre>
<p>And we see we got a list whose first element is the empty the list. The second element is a map with int keys and values. Etc.</p>
<hr />
<p>Check out <a href="generator-examples.html">page two</a> for more examples of using generators in practice.</p></div></div></div><script>window.klipse_settings = {
    selector: '.klipse,.clojure',
    codemirror_options_in: {
    lineWrapping: true,
    autoCloseBrackets: true
    },
    codemirror_options_out: {
    lineWrapping: true
    }
    };</script><script>
    function klipseLocalStorageEnabled() {
        var mod = 'modernizr';
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
     }
     function klipseLoad() {
      if (klipseLocalStorageEnabled()) { sessionStorage.setItem('klipse', true);}
      $('#klipse-button').remove();
      var s = document.createElement('script');
      s.setAttribute('src','https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js');
      document.head.appendChild(s);
      }
    if(!true) {
      klipseLoad();
    } else {
      if((klipseLocalStorageEnabled() && sessionStorage.getItem('klipse')) || window.location.search.match(/klipse=1/)) {
        klipseLoad();
      } else {
        $('#klipse-button').click(function(){
        klipseLoad();
       });
      }
    }
    </script></body></html>